<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage examples · Caching.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Caching.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li class="current"><a class="toctext" href>Usage examples</a><ul class="internal"><li><a class="toctext" href="#The-Cache-object-1">The <code>Cache</code> object</a></li><li><a class="toctext" href="#Memory-and-disk-memoization-1">Memory and disk memoization</a></li><li><a class="toctext" href="#Cache-misses-1">Cache misses</a></li><li><a class="toctext" href="#Memory-disk-synchronization-1">Memory-disk synchronization</a></li><li class="toplevel"><a class="toctext" href="#Maximum-sizes-1">Maximum sizes</a></li><li class="toplevel"><a class="toctext" href="#Serialization-1">Serialization</a></li></ul></li><li><a class="toctext" href="../api/">API Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Usage examples</a></li></ul><a class="edit-page" href="https://github.com/zgornel/Caching.jl/blob/master/docs/src/examples.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Usage examples</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Usage-examples-1" href="#Usage-examples-1">Usage examples</a></h1><p>The following examples show how <code>Caching</code> can be employed to cache function outputs. Most examples employ the macros as this is the most straightforward usage pattern.</p><h2><a class="nav-anchor" id="The-Cache-object-1" href="#The-Cache-object-1">The <code>Cache</code> object</a></h2><p>The caching object is named <code>Cache</code> and it can be easily constructed using the <code>@cache</code> macro. There are several supported expressions that can be used to construct <code>Cache</code>s:</p><pre><code class="language-julia-repl">julia&gt; using Caching, InteractiveUtils, Serialization</code></pre><pre><code class="language-julia-repl">julia&gt; @cache function foo(x)
           x+1
       end
foo (cache with 0 entries, 0 in memory 0 on disk)

julia&gt; typeof(foo)
Cache{typeof(Main.ex-index.f_CDLnhxHDfxcK1ZtyhuhY),Any,CountSize}

julia&gt; @code_warntype foo(1)
Variables
  cache::Cache{typeof(Main.ex-index.f_CDLnhxHDfxcK1ZtyhuhY),Any,CountSize}
  args::Tuple{Int64}

Body::ANY
1 ─ %1 = Core.NamedTuple()::Core.Compiler.Const(NamedTuple(), false)
│   %2 = Base.pairs(%1)::Core.Compiler.Const(Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}(), false)
│   %3 = Core.tuple(%2, cache)::Core.Compiler.PartialStruct(Tuple{Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}},Cache{typeof(Main.ex-index.f_CDLnhxHDfxcK1ZtyhuhY),Any,CountSize}}, Any[Core.Compiler.Const(Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}(), false), Cache{typeof(Main.ex-index.f_CDLnhxHDfxcK1ZtyhuhY),Any,CountSize}])
│   %4 = Core._apply(Caching.:(var&quot;#_#4&quot;), %3, args)::ANY
└──      return %4</code></pre><p>or, for type stability,</p><pre><code class="language-julia-repl">julia&gt; @cache function foo2(x)::Int
           x+1
       end
foo2 (cache with 0 entries, 0 in memory 0 on disk)

julia&gt; @code_warntype foo2(1)
Variables
  cache::Cache{typeof(Main.ex-index.f_bfHJuGeubaFR9B4r2j0t),Int64,CountSize}
  args::Tuple{Int64}

Body::Int64
1 ─ %1 = Core.NamedTuple()::Core.Compiler.Const(NamedTuple(), false)
│   %2 = Base.pairs(%1)::Core.Compiler.Const(Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}(), false)
│   %3 = Core.tuple(%2, cache)::Core.Compiler.PartialStruct(Tuple{Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}},Cache{typeof(Main.ex-index.f_bfHJuGeubaFR9B4r2j0t),Int64,CountSize}}, Any[Core.Compiler.Const(Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}(), false), Cache{typeof(Main.ex-index.f_bfHJuGeubaFR9B4r2j0t),Int64,CountSize}])
│   %4 = Core._apply(Caching.:(var&quot;#_#4&quot;), %3, args)::Int64
└──      return %4</code></pre><p>The approach works for anonymous functions as well:</p><pre><code class="language-julia-repl">julia&gt; @cache foo3 = x-&gt;x-1
foo3 (cache with 0 entries, 0 in memory 0 on disk)</code></pre><p>or, for type stability,</p><pre><code class="language-julia-repl">julia&gt; @cache foo4 = x::Int-&gt;x-1
foo4 (cache with 0 entries, 0 in memory 0 on disk)

julia&gt; @code_warntype foo3(1)
Variables
  cache::Cache{Main.ex-index.var&quot;#1#2&quot;,Any,CountSize}
  args::Tuple{Int64}

Body::ANY
1 ─ %1 = Core.NamedTuple()::Core.Compiler.Const(NamedTuple(), false)
│   %2 = Base.pairs(%1)::Core.Compiler.Const(Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}(), false)
│   %3 = Core.tuple(%2, cache)::Core.Compiler.PartialStruct(Tuple{Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}},Cache{Main.ex-index.var&quot;#1#2&quot;,Any,CountSize}}, Any[Core.Compiler.Const(Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}(), false), Cache{Main.ex-index.var&quot;#1#2&quot;,Any,CountSize}])
│   %4 = Core._apply(Caching.:(var&quot;#_#4&quot;), %3, args)::ANY
└──      return %4

julia&gt; @code_warntype foo4(1)
Variables
  cache::Cache{Main.ex-index.var&quot;#3#4&quot;,Int64,CountSize}
  args::Tuple{Int64}

Body::Int64
1 ─ %1 = Core.NamedTuple()::Core.Compiler.Const(NamedTuple(), false)
│   %2 = Base.pairs(%1)::Core.Compiler.Const(Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}(), false)
│   %3 = Core.tuple(%2, cache)::Core.Compiler.PartialStruct(Tuple{Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}},Cache{Main.ex-index.var&quot;#3#4&quot;,Int64,CountSize}}, Any[Core.Compiler.Const(Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}(), false), Cache{Main.ex-index.var&quot;#3#4&quot;,Int64,CountSize}])
│   %4 = Core._apply(Caching.:(var&quot;#_#4&quot;), %3, args)::Int64
└──      return %4</code></pre><h2><a class="nav-anchor" id="Memory-and-disk-memoization-1" href="#Memory-and-disk-memoization-1">Memory and disk memoization</a></h2><p>The <code>Cache</code> object itself supports reading/writing cached entries from/to memory and to disk.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Re-using the cached function outputs from a file is not possible once the in-memory <code>Cache</code> object goes out of scope.</p></div></div><pre><code class="language-julia-repl">julia&gt; foo5(x) = x+1
foo5 (generic function with 1 method)

julia&gt; dc = @cache foo5 &quot;somefile.bin&quot;
foo5 (cache with 0 entries, 0 in memory 0 on disk)

julia&gt; dc(1);  # add one entry to cache

julia&gt; dc.cache
Dict{UInt64,Any} with 1 entry:
  0xc159d77b031aa8af =&gt; 2

julia&gt; dc.offsets  # disk cache information (hash=&gt;(start byte, end byte))
Dict{UInt64,Tuple{UInt64,UInt64}} with 0 entries

julia&gt; dc.filename  # file information
&quot;/home/travis/build/zgornel/Caching.jl/docs/build/somefile.bin&quot;

julia&gt; isfile(dc.filename)  # file does not exist
false</code></pre><p>The cache can be written to disk using the <code>persist!</code> function or the <code>@persist!</code> macro:</p><pre><code class="language-julia-repl">julia&gt; @persist! dc  # writes cache to disk and updates offsets
foo5 (cache with 1 entry, 1 in memory 1 on disk)

julia&gt; isfile(dc.filename)
true

julia&gt; dc.offsets
Dict{UInt64,Tuple{UInt64,UInt64}} with 1 entry:
  0xc159d77b031aa8af =&gt; (0x0000000000000009, 0x0000000000000012)</code></pre><p>The cache can be deleted using the <code>empty!</code> function or the <code>@empty!</code> macro:</p><pre><code class="language-julia-repl">julia&gt; @empty! dc  # delete memory cache
foo5 (cache with 1 entry, 0 in memory 1 on disk)

julia&gt; @empty! dc true  # delete also the disk cache
foo5 (cache with 0 entries, 0 in memory 0 on disk)

julia&gt; isfile(&quot;somefile.bin&quot;)
false</code></pre><p>If no file name is provided when creating a <code>Cache</code> object, a file name will be automatically generated:</p><pre><code class="language-julia-repl">julia&gt; dc = @cache foo5
foo5 (cache with 0 entries, 0 in memory 0 on disk)

julia&gt; dc.filename
&quot;/home/travis/build/zgornel/Caching.jl/docs/build/_9aec8ed5aa424656_.bin&quot;</code></pre><h2><a class="nav-anchor" id="Cache-misses-1" href="#Cache-misses-1">Cache misses</a></h2><p>In case of a cache memory miss, the cached data is retrieved from disk if available:</p><pre><code class="language-julia-repl">julia&gt; dc = @cache foo5::Int &quot;somefile.bin&quot;
foo5 (cache with 0 entries, 0 in memory 0 on disk)

julia&gt; for i in 1:3 dc(i); end              # add 3 entries

julia&gt; @persist! dc
foo5 (cache with 3 entries, 3 in memory 3 on disk)

julia&gt; @assert isfile(&quot;somefile.bin&quot;)

julia&gt; @empty! dc                           # empty memory cache
foo5 (cache with 3 entries, 0 in memory 3 on disk)

julia&gt; @assert isempty(dc.cache)

julia&gt; for i in 4:6 dc(i); end              # add 3 new entries

julia&gt; dc
foo5 (cache with 6 entries, 3 in memory 3 on disk)

julia&gt; dc(1)  # only on disk
2

julia&gt; dc(4)  # in memory
5</code></pre><h2><a class="nav-anchor" id="Memory-disk-synchronization-1" href="#Memory-disk-synchronization-1">Memory-disk synchronization</a></h2><p>Synchronization between the memory and disk cache contents is done with the help of the <code>syncache!</code> function and <code>@syncache!</code> macro:</p><pre><code class="language-julia-repl">julia&gt; dc = @cache foo5 &quot;somefile.bin&quot;       # make a Cache object
foo5 (cache with 0 entries, 0 in memory 0 on disk)

julia&gt; for i in 1:5 dc(i); end              # populate the memory cache with 5 entries

julia&gt; @persist! dc                         # write to disk the cache the 5 entries
foo5 (cache with 5 entries, 5 in memory 5 on disk)

julia&gt; @empty! dc                           # delete the memory cache
foo5 (cache with 5 entries, 0 in memory 5 on disk)

julia&gt; @syncache! dc &quot;disk&quot;                 # load cache from disk
foo5 (cache with 5 entries, 5 in memory 5 on disk)

julia&gt; @empty! dc  # empty memory cache
foo5 (cache with 5 entries, 0 in memory 5 on disk)

julia&gt; for i in 1:3  dc(-i); end            # populate the memory cache with 3 new entries

julia&gt; @syncache! dc &quot;memory&quot;               # write memory cache to disk
foo5 (cache with 8 entries, 3 in memory 8 on disk)

julia&gt; @empty! dc
foo5 (cache with 8 entries, 0 in memory 8 on disk)

julia&gt; @syncache! dc &quot;disk&quot;                 # load cache from disk
foo5 (cache with 8 entries, 8 in memory 8 on disk)

julia&gt; dc.cache  # view the cache
Dict{UInt64,Any} with 8 entries:
  0xc0e8089aaf6365bf =&gt; 6
  0xcfd1bb447236eae7 =&gt; 4
  0x5717fd56af052f04 =&gt; 0
  0xc159d77b031aa8af =&gt; 2
  0x36317c6768130f8c =&gt; 3
  0x1ac8353e20a225f8 =&gt; -1
  0xf0f39ef33944221b =&gt; 5
  0xa0c5b6bee44db0f8 =&gt; -2

julia&gt; dc.offsets  # view the file offsets
Dict{UInt64,Tuple{UInt64,UInt64}} with 8 entries:
  0xc0e8089aaf6365bf =&gt; (0x000000000000002d, 0x0000000000000036)
  0xc159d77b031aa8af =&gt; (0x0000000000000009, 0x0000000000000012)
  0xcfd1bb447236eae7 =&gt; (0x000000000000001b, 0x0000000000000024)
  0x5717fd56af052f04 =&gt; (0x0000000000000036, 0x000000000000003f)
  0x36317c6768130f8c =&gt; (0x0000000000000012, 0x000000000000001b)
  0x1ac8353e20a225f8 =&gt; (0x000000000000003f, 0x000000000000004c)
  0xf0f39ef33944221b =&gt; (0x0000000000000024, 0x000000000000002d)
  0xa0c5b6bee44db0f8 =&gt; (0x000000000000004c, 0x0000000000000059)</code></pre><p>Synchronization of disk and memory cache contents can also be performed in one go by passing <code>&quot;both&quot;</code> in the <code>@syncache!</code> macro call:</p><pre><code class="language-julia-repl">julia&gt; dc = @cache foo5;

julia&gt; for i in 1:3 dc(i); end              # populate the memory cache with 3 entries

julia&gt; @syncache! dc &quot;memory&quot;               # write to disk the 3 entries
foo5 (cache with 3 entries, 3 in memory 3 on disk)

julia&gt; @empty! dc                           # delete the in-memory cache
foo5 (cache with 3 entries, 0 in memory 3 on disk)

julia&gt; for i in 1:5 dc(-i); end             # populate the in-memory cache with 5 new entries

julia&gt; @syncache! dc &quot;both&quot;                 # sync both memory and disk
foo5 (cache with 8 entries, 8 in memory 8 on disk)

julia&gt; dc.cache
Dict{UInt64,Any} with 8 entries:
  0xcfd1bb447236eae7 =&gt; 4
  0x5717fd56af052f04 =&gt; 0
  0x54ccc0bf21828ced =&gt; -3
  0xc49d73501c07ec93 =&gt; -4
  0x1ac8353e20a225f8 =&gt; -1
  0x36317c6768130f8c =&gt; 3
  0xc159d77b031aa8af =&gt; 2
  0xa0c5b6bee44db0f8 =&gt; -2</code></pre><h1><a class="nav-anchor" id="Maximum-sizes-1" href="#Maximum-sizes-1">Maximum sizes</a></h1><p><code>Cache</code> objects support maximum sizes in terms of either number of entries (i.e. function outputs) or the maximum memory size allowed:</p><pre><code class="language-julia-repl">julia&gt; foo6(x) = x
foo6 (generic function with 1 method)

julia&gt; dc = @cache foo6 &quot;somefile.bin&quot; 3     # 3 objects max; use Int for objects
foo6 (cache with 0 entries, 0 in memory 0 on disk)

julia&gt; for i in 1:3 dc(i) end               # cache is full

julia&gt; dc(4)                                # 1 is removed (FIFO rule)
4

julia&gt; @assert !(1 in values(dc.cache)) &amp;&amp;
           all(i in values(dc.cache) for i in 2:4)

julia&gt; @persist! dc
foo6 (cache with 3 entries, 3 in memory 3 on disk)

julia&gt; @empty! dc                           # 2,3,4 on disk
foo6 (cache with 3 entries, 0 in memory 3 on disk)

julia&gt; for i in 5:6 dc(i) end               # 5 and 6 in memory

julia&gt; @syncache! dc                        # brings 4 (most recent on disk) in memory and writes 5,6 on disk
┌ Warning: Memory cache full, loaded 1 out of 3 entries.
└ @ Caching ~/build/zgornel/Caching.jl/src/utils.jl:129
foo6 (cache with 5 entries, 3 in memory 5 on disk)</code></pre><pre><code class="language-julia-repl">julia&gt; dc = @cache foo6 &quot;somefile.bin&quot; 1.0   # 1.0 --&gt; 1 KiB = 1024 bytes max; use Float64 for KiB
foo6 (cache with 0 entries, 0 in memory 0 on disk)

julia&gt; for i in 1:128 dc(i) end             # cache is full (128 x 8bytes/Int = 1024 bytes)

julia&gt; dc(129)                              # 1 is removed
129

julia&gt; @assert !(1 in values(dc.cache)) &amp;&amp;
           all(i in values(dc.cache) for i in 2:129)

julia&gt; @persist! dc
foo6 (cache with 128 entries, 128 in memory 128 on disk)

julia&gt; @empty! dc                           # 2,...,129 on disk, nothing in memory
foo6 (cache with 128 entries, 0 in memory 128 on disk)

julia&gt; for i in 130:130+126 dc(i) end       # write 127 entries

julia&gt; #--&gt; 130,..,256 in memory, 2,...,129 on disk
       @syncache! dc                        # brings 129 in memory and 130,...,256 on disk
┌ Warning: Memory cache full, loaded 1 out of 128 entries.
└ @ Caching ~/build/zgornel/Caching.jl/src/utils.jl:129
foo6 (cache with 255 entries, 128 in memory 255 on disk)</code></pre><h1><a class="nav-anchor" id="Serialization-1" href="#Serialization-1">Serialization</a></h1><div class="admonition compat"><div class="admonition-title">Caching 0.2.0</div><div class="admonition-text"><p>This feature requires version 0.2.0</p></div></div><p>It is possible to save and load <code>Cache</code> objects to and from disk. This does not refer to the disk cache associated with an object but rather the object itself. The straightforward approach is to generate a cache object through the <code>@cache</code> macro and define the function withing the scope of the call:</p><pre><code class="language-julia-repl">julia&gt; @cache foo = x-&gt;begin println(&quot;this is foo.&quot;); true; end
foo (cache with 0 entries, 0 in memory 0 on disk)

julia&gt; serialize(&quot;foo.serialized.bin&quot;, foo)

julia&gt; foo_d = deserialize(&quot;foo.serialized.bin&quot;, Cache)
foo (cache with 0 entries, 0 in memory 0 on disk)

julia&gt; @assert foo_d(1)  # result not cached
this is foo.

julia&gt; foo_d(1)  # result cached
true</code></pre><p>One can check the that the code of the function is captured:</p><pre><code class="language-julia-repl">julia&gt; println(foo_d.func_def)
x::Any-&gt;begin
        #= /home/travis/build/zgornel/Caching.jl/src/cache.jl:201 =#
        begin
            #= none:1 =#
            #= none:1 =#
            println(&quot;this is foo.&quot;)
            #= none:1 =#
            true
        end
    end</code></pre><p>The approach works in a similar way for definitions of the form <code>@cache function bar(x) end</code></p><p>If the <code>Cache</code> object is created by directly specifying an existing function, the only way to recover full functionality is to manually specify the same function when deserializing:</p><pre><code class="language-julia-repl">julia&gt; bar(x) = x
bar (generic function with 1 method)

julia&gt; barc = @cache bar  # `bar` code is unknwon
bar (cache with 0 entries, 0 in memory 0 on disk)

julia&gt; serialize(&quot;bar.serialized.bin&quot;, barc)

julia&gt; bar_d = deserialize(&quot;bar.serialized.bin&quot;, Cache)  # fails, cannot recreate function `bar`
ERROR: Cannot reconstruct cache; use the `func` keyword argument.

julia&gt; bar_d = deserialize(&quot;bar.serialized.bin&quot;, Cache; func=bar)  # works, bar is known
bar (cache with 0 entries, 0 in memory 0 on disk)

julia&gt; bar_d(1)
1</code></pre><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><ul><li><p>Any function can be provided through the <code>func</code> keyword argument and this may result in undefined behavior; it is up to the user to provide the original cached function.</p></li><li><p>This approach is independent of the disk cache associated with the <code>Cache</code> object and portability has again to be explicitly ensured i.e. if moving the serialized objects and disk caches across machines the path of the disk cache (<code>filename</code> property) may have to be manually changed.</p></li></ul></div></div><p>More usage examples can be found in the <a href="https://github.com/zgornel/Caching.jl/blob/master/test/runtests.jl">test/runtests.jl</a> file.</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="../api/"><span class="direction">Next</span><span class="title">API Reference</span></a></footer></article></body></html>
